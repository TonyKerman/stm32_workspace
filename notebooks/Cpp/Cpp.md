# 函数

## 函数指针

double (*pf)(int);*pf是函数，所以(*pf)是函数指针

double *pf(int); 声明一个返回double指针的函数

eg:

        double f1(int); 
        double (*pf)(int);
        pf = f1;//令pf指向f1

## 内联函数

执行时用代码替换函数调用，类似于宏#define(有区别)
用于代码量小的函数，节省时间

### 使用

在声明和定义前加 inline

eg

        inline int func(int arg){...}

## 引用

### 引用变量

变量的别名，同时改变

    int & a =b

### 函数引用参数

让函数改变传入的变量，区别于按值传递

void func(int &a)

不能这样调用 func(x+1);

如果形参实参类型不匹配，将会创建临时变量，实现不了改变传入参数的功能，

### 引用结构

引用结构可以让函数改变结构中的成员

不需要改变时，可以节省时间和内存(使用const引用)
int func(const strct &s)

### 返回引用

返回引用
int & func(int & b){....return b}

应该避免返回（函数结束后不存在的变量）的引用,建议返回一个作为参数传递进来的引用

### 引用对象

建议引用对象,节省内存,同时注意使用const防止不必要的修改

### 何时使用引用

使用引用参数的主要原因有两个。

1.程序员能够修改调用函数中的数据对象。

2.通过传递引用而不是整个数据对象，可以提高程序的运行速度。

当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。那么，什么时候应使用引用、什么时候应使用指针呢？什么时候应按值传递呢？下面是一些指导原则：

#### 对于使用传递的值而不作修改的函数

* 如果数据对象很小，如内置数据类型或小型结构，则按值传递。

* 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。

* 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。

* 如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。

#### 对于修改调用函数中数据的函数

* 如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit（&x）这样的代码（其中x是int），则很明显，该函数将修改x。

* 如果数据对象是数组，则只能使用指针。

* 如果数据对象是结构，则使用引用或指针。

* 如果数据对象是类对象，则使用引用。

## 函数重载(多态)

相同的名称,不同的参数(类型,顺序),函数类型

eg
    int func(int a,int b);
    float func(int a float b);
匹配函数时根据的是 特征标 即参数的类型和顺序

### 注意

const和非const无法区分,类型引用和类型本身无法区分

    int func(int x);
    int func(int &x);
报错

## 函数模板

当算法相同,参数类型不同时,可使用模板

#### 格式

        template <typename T1,typename T2>
        void func(T1 a, T2阿 b);

typename:关键字,可用class替换

T:自定义的类型

* 模板函数也可以重载

### 显式具体化

当某一个类型的算法与其他类型不同时(例如结构与数不同),可以显式定义针对它的代码

类似于重载

#### 格式

         tmeplat<> void func<mystruct>(mystruct a,mystruct b);

### 优先级

普通函数>显式具体化模板>通用模板

### 显式实例化

调用函数时,可以进行强制类型转换

        func<int>(a,b);

### decltype关键字(C++11)

在编写模板函数内容时,可能需要通过参数的运算来得到返回值的类型

        int a flaot b
        decltype(a*b) x = a*b;

### 后置返回类型

当函数返回类型由参数决定时,使用后置返回类型

        auto func(int a,int b) ->double
        template <typename T1,T2>
        auto func(T1 a,T2 b) ->decltype(a+b)
        {
        return a+b;
        }

# 作用域,命名空间

作用域:变量生效的范围
链接性:内部(单个文件),外部
持续性:变量生存的时间

* 自动储存:函数内定义的变量在函数结束后删除
* 静态储存:在函数内使用 static 关键字定义的变量和在函数外定义的变量
* 动态储存:new delete

### 在函数内使用 static 定义变量:无链接性(不能在函数外使用),静态(不在函数结束时销毁)

### 在函数外使用 static 定义变量:内部链接性(只在此文件中生效),静态

### 在多个文件中使用外部变量 extern 声明

#### volatile限定符:表明程序不修改变量值也可能变化

# 其他

### 获取变量名称

    #define VNAME(value) (#value)
分析：在宏VNAME中，我们使用了#，这个#出现在宏中，表示对后面的变量替换的时候，用双引号""括起来，刚好满足我们的需求。
