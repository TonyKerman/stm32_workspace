
# notebook 队列

基于 FreeRTOS 的应用程序由一组独立的任务构成——每个任务都是具有独立权
限的小程序。这些独立的任务之间很可能会通过相互通信以提供有用的系统功能。
FreeRTOS 中所有的通信与同步机制都是基于队列实现的。

## 队列的特性

### 数据存储

队列可以保存有限个具有确定长度的数据单元。队列可以保存的最大单元数目被称
为队列的“深度”。在队列创建时需要设定其深度和每个单元的大小。

通常情况下，队列被作为 FIFO(先进先出)使用，即数据由队列尾写入，从队列首读
出。当然，由队列首写入也是可能的。
往队列写入数据是通过字节拷贝把数据复制存储到队列中；从队列读出数据使得把
队列中的数据拷贝删除。

### 可被多任务存取

### 读队列时阻塞

当某个任务试图读一个队列时，其可以指定一个阻塞超时时间。在这段时间中，如
果队列为空，该任务将保持阻塞状态以等待队列数据有效。当其它任务或中断服务例程
往其等待的队列中写入了数据，该任务将自动由阻塞态转移为就绪态。当等待的时间超
过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转移为就绪态。
由于队列可以被多个任务读取，所以对单个队列而言，也可能有多个任务处于阻塞
状态以等待队列数据有效。这种情况下，一旦队列数据有效，只会有一个任务会被解除
阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级
相同，那么被解除阻塞的任务将是等待最久的任务。

### 写队列时阻塞

同读队列一样，任务也可以在写队列时指定一个阻塞超时时间。这个时间是当被写
队列已满时，任务进入阻塞态以等待队列空间有效的最长时间。
由于队列可以被多个任务写入，所以对单个队列而言，也可能有多个任务处于阻塞
状态以等待队列空间有效。这种情况下，一旦队列空间有效，只会有一个任务会被解除
阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级
相同，那么被解除阻塞的任务将是等待最久的任务。

## 使用队列

### 声明

xQueueHandle q1;

### 定义: xQueueCreate() API 函数

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength,
unsigned portBASE_TYPE uxItemSize );

#### 参数名

* uxQueueLength 队列能够存储的最大单元数目，即队列深度。

* uxItemSize 队列中数据单元的长度，以字节为单位。

#### 返回值

1. NULL 表示没有足够的堆空间分配给队列而导致创建失败。

2. 非 NULL 值表示队列创建成功。此返回值应当保存下来，以作为操作此队列的句柄。

### 发送数据: xQueueSendToBack() (xQueueSend())与 xQueueSendToFront() API 函数

portBASE_TYPE xQueueSend( xQueueHandle xQueue, const void * pvItemToQueue,
portTickType xTicksToWait );

#### 参数名

* xQueue 目标队列的句柄。这个句柄即是调用 xQueueCreate()创建该队
列时的返回值。
pvItemToQueue 发送数据的指针。其指向将要复制到目标队列中的数据单元。
由于在创建队列时设置了队列中数据单元的长度，所以会从该指
针指向的空间复制对应长度的数据到队列的存储区域。
xTicksToWait 阻塞超时时间。如果在发送时队列已满，这个时间即是任务处于
阻塞态等待队列空间有效的最长等待时间。
如 果 xTicksToWait 设 为 0 ，并且队列已满，则
xQueueSendToFront()与 xQueueSendToBack()均会立即返回。
阻塞时间是以系统心跳周期为单位的，所以绝对时间取决于系统
心跳频率。常量 portTICK_RATE_MS 可以用来把心跳时间单位
转换为毫秒时间单位。
如果把 xTicksToWait 设置为 portMAX_DELAY ，并且在
FreeRTOSConig.h 中设定 INCLUDE_vTaskSuspend 为 1，那
么阻塞等待将没有超时限制。

#### 返回值 (有两个可能的返回值)

1. pdPASS
返回 pdPASS 只会有一种情况，那就是数据被成功发送到队列
中。
如果设定了阻塞超时时间(xTicksToWait 非 0)，在函数返回之前
任务将被转移到阻塞态以等待队列空间有效—在超时到来前能
够将数据成功写入到队列，函数则会返回 pdPASS。

2. errQUEUE_FULL
如果由于队列已满而无法将数据写入，则将返回
errQUEUE_FULL。
如果设定了阻塞超时时间（xTicksToWait 非 0），在函数返回之
前任务将被转移到阻塞态以等待队列空间有效。但直到超时也没
有其它任务或是中断服务例程读取队列而腾出空间，函数则会返
回 errQUEUE_FULL。

### 当队列长为1时写入 xQueueOverwrite()

BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue );

写入数据，当队列满时覆盖存在的值

返回值:与 xQueueSend()一样

### (从队首)接收数据: xQueueReceive()与 xQueuePeek() API 函数

xQueueReceive()用于从队列中接收(读取)数据单元。接收到的单元同时会从队列
中删除。

xQueuePeek()也是从从队列中接收数据单元，不同的是并不从队列中删出接收到
的单元。xQueuePeek()从队列首接收到数据后，不会修改队列中的数据，也不会改变
数据在队列中的存储序顺。

切记不要在中断服务例程中调用 xQueueRceive()和 xQueuePeek()。中断安全版本
的替代 API 函数 xQueueReceiveFromISR()

portBASE_TYPE xQueueReceive( xQueueHandle xQueue,const void * pvBuffer,portTickType xTicksToWait );

#### 参数名

* xQueue 被读队列的句柄。这个句柄即是调用 xQueueCreate()创建该队列
时的返回值。

* pvBuffer 接收缓存指针。其指向一段内存区域，用于接收从队列中拷贝来
的数据。
数据单元的长度在创建队列时就已经被设定，所以该指针指向的
内存区域大小应当足够保存一个数据单元。
* xTicksToWait 阻塞超时时间。如果在接收时队列为空，则这个时间是任务处于
阻塞状态以等待队列数据有效的最长等待时间。
如果 xTicksToWait 设为 0，并且队列为空，则 xQueueRecieve()
与 xQueuePeek()均会立即返回。
阻塞时间是以系统心跳周期为单位的，所以绝对时间取决于系统
心跳频率。常量 portTICK_RATE_MS 可以用来把心跳时间单位转
换为毫秒时间单位。
如果把 xTicksToWait 设置为 portMAX_DELAY ，并且在
FreeRTOSConig.h 中设定 INCLUDE_vTaskSuspend 为 1，那么
阻塞等待将没有超时限制。

#### 返回值 有两个可能的返回值

1. pdPASS
只有一种情况会返回 pdPASS，那就是成功地从队列中读到数据。
如果设定了阻塞超时时间(xTicksToWait 非 0)，在函数返回之前任
务将被转移到阻塞态以等待队列数据有效—在超时到来前能够从
队列中成功读取数据，函数则会返回 pdPASS。

2. errQUEUE_FULL
如果在读取时由于队列已空而没有读到任何数据，则将返回
errQUEUE_FULL。
如果设定了阻塞超时时间（xTicksToWait 非 0），在函数返回之前
任务将被转移到阻塞态以等待队列数据有效。但直到超时也没有
其它任务或是中断服务例程往队列中写入数据，函数则会返回
errQUEUE_FULL。

### 查询队列中当前有效数据单元个数

unsigned portBASE_TYPE uxQueueMessagesWaiting( xQueueHandle xQueue );

### 工作于大型数据单元

如果队列存储的数据单元尺寸较大，那最好是利用队列来传递数据的指针而不是对
数据本身在队列上一字节一字节地拷贝进或拷贝出。传递指针无论是在处理速度上还是
内存空间利用上都更有效。但是，当你利用队列传递指针时，一定要十分小心地做到以
下两点：

1. 指针指向的内存空间的所有权必须明确
当任务间通过指针共享内存时，应该从根本上保证所不会有任意两个任务同时
修改共享内存中的数据，或是以其它行为方式使得共享内存数据无效或产生一致性
问题。原则上，共享内存在其指针发送到队列之前，其内容只允许被发送任务访问；
共享内存指针从队列中被读出之后，其内容亦只允许被接收任务访问。

2. 指针指向的内存空间必须有效
如果指针指向的内存空间是动态分配的，只应该有一个任务负责对其进行内存
释放。当这段内存空间被释放之后，就不应该有任何一个任务再访问这段空间。
切忌用指针访问任务栈上分配的空间。因为当栈帧发生改变后，栈上的数据将不再
有效。

